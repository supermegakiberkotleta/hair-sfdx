# Оптимизация триггера TrackLeadStatus

## Проблема
Триггер `TrackLeadStatus` падал с ошибкой `CANNOT_INSERT_UPDATE_ACTIVATE_ENTITY: TrackLeadStatus: System.LimitException: Too many SOQL queries: 101` при одновременном обновлении большого количества лидов.

## Причины проблемы
1. **Слишком много SOQL запросов**: Триггер выполнял множество запросов в цикле
2. **Неэффективная логика**: Каждый лид обрабатывался отдельно
3. **Отсутствие обработки губернаторов**: Нет проверки лимитов Salesforce

## Решение

### 1. Queueable подход
Создан класс `LeadStatusHistoryQueueable`, который:
- Обрабатывает данные асинхронно
- Избегает лимитов триггера
- Оптимизирует SOQL запросы
- Обрабатывает ошибки

### 2. Оптимизированный триггер
Новый триггер:
- Собирает данные для обработки
- Запускает Queueable только при необходимости
- Проверяет лимиты перед запуском
- Минимальная нагрузка на транзакцию

### 3. Batch класс для больших объемов
Создан `LeadStatusHistoryBatch` для:
- Обработки исторических данных
- Массовых операций
- Обработки больших объемов записей

## Структура решения

### Файлы
- `TrackLeadStatus.trigger` - оптимизированный триггер
- `LeadStatusHistoryQueueable.cls` - асинхронная обработка
- `LeadStatusHistoryQueueableTest.cls` - тесты для Queueable
- `LeadStatusHistoryBatch.cls` - batch обработка
- `LeadStatusHistoryBatchTest.cls` - тесты для Batch

### Основные улучшения

#### 1. Снижение количества SOQL запросов
**Было**: Множество запросов в цикле
**Стало**: Оптимизированные запросы с группировкой

#### 2. Асинхронная обработка
**Было**: Синхронная обработка в триггере
**Стало**: Queueable для асинхронной обработки

#### 3. Обработка ошибок
**Было**: Отсутствие обработки ошибок
**Стало**: Try-catch блоки и логирование

#### 4. Проверка лимитов
**Было**: Нет проверки лимитов
**Стало**: Проверка лимитов Queueable перед запуском

## Использование

### Автоматическое использование
Триггер автоматически использует Queueable при обновлении лидов.

### Ручной запуск Batch
```apex
// Запуск batch для всех лидов
LeadStatusHistoryBatch.startBatch();

// Запуск batch с кастомным запросом
String customQuery = 'SELECT Id, Status FROM Lead WHERE Status = \'New\'';
LeadStatusHistoryBatch.startBatch(customQuery);
```

### Ручной запуск Queueable
```apex
Set<Id> leadIds = new Set<Id>{'001xx000003DIloAAG'};
Map<Id, String> statusMap = new Map<Id, String>{'001xx000003DIloAAG' => 'Qualified'};
LeadStatusHistoryQueueable queueable = new LeadStatusHistoryQueueable(leadIds, statusMap, false);
System.enqueueJob(queueable);
```

## Преимущества

1. **Производительность**: Значительное снижение нагрузки на систему
2. **Масштабируемость**: Обработка больших объемов данных
3. **Надежность**: Обработка ошибок и восстановление
4. **Гибкость**: Возможность ручного запуска для исторических данных

## Мониторинг

### Логирование
- Ошибки логируются в System.debug
- Можно добавить логирование в отдельную таблицу

### Метрики
- Количество обработанных записей
- Количество ошибок
- Время выполнения

## Рекомендации

1. **Мониторинг**: Следите за логами Queueable и Batch
2. **Тестирование**: Запускайте тесты перед деплоем
3. **Оптимизация**: При необходимости настройте размер батча
4. **Резервное копирование**: Создайте резервные копии перед массовыми операциями 